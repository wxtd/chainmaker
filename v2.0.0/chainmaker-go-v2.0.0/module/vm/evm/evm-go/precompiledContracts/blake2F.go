/*
 * Copyright 2020 The SealEVM Authors
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package precompiledContracts

import (
	"encoding/binary"
	"errors"
)

type blake2F struct{}

//func (c *blake2F)SetValue(v string){}

func (c *blake2F) GasCost(input []byte) uint64 {
	// If the input is malformed, we can't calculate the gas, return 0 and let the
	// actual call choke and fault.
	if len(input) != blake2FInputLength {
		return 0
	}
	return uint64(binary.BigEndian.Uint32(input[0:4]))
}

const (
	blake2FInputLength        = 213
	blake2FFinalBlockBytes    = byte(1)
	blake2FNonFinalBlockBytes = byte(0)
)

var (
	errBlake2FInvalidInputLength = errors.New("invalid input length")
	errBlake2FInvalidFinalFlag   = errors.New("invalid final flag")
)

func (c *blake2F) Execute(input []byte) ([]byte, error) {
	//// Make sure the input is valid (correct lenth and final flag)
	//if len(input) != blake2FInputLength {
	//	return nil, errBlake2FInvalidInputLength
	//}
	//if input[212] != blake2FNonFinalBlockBytes && input[212] != blake2FFinalBlockBytes {
	//	return nil, errBlake2FInvalidFinalFlag
	//}
	//// Parse the input into the Blake2b call parameters
	//var (
	//	rounds = binary.BigEndian.Uint32(input[0:4])
	//	final  = input[212] == blake2FFinalBlockBytes
	//
	//	h [8]uint64
	//	m [16]uint64
	//	t [2]uint64
	//)
	//for i := 0; i < 8; i++ {
	//	offset := 4 + i*8
	//	h[i] = binary.LittleEndian.Uint64(input[offset : offset+8])
	//}
	//for i := 0; i < 16; i++ {
	//	offset := 68 + i*8
	//	m[i] = binary.LittleEndian.Uint64(input[offset : offset+8])
	//}
	//t[0] = binary.LittleEndian.Uint64(input[196:204])
	//t[1] = binary.LittleEndian.Uint64(input[204:212])
	//
	//// Execute the compression function, extract and return the result
	//blake2b.F(&h, m, t, final, rounds)
	//
	//output := make([]byte, 64)
	//for i := 0; i < 8; i++ {
	//	offset := i * 8
	//	binary.LittleEndian.PutUint64(output[offset:offset+8], h[i])
	//}
	//return output, nil
	return nil, nil
}
